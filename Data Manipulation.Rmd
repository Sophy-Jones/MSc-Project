---
title: "Data Manipulation"
author: "Sophy Jones"
date: "07/07/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load the packages needed
```{r}
library(raster) # for dealing with spatial data
library(dplyr) # for handy data manipulation functions
library(tidyr) # ditto
library(lme4) # for mixed effects models
library(car) # for getting anova tables with significance values
library(DHARMa) # for model criticism plots
library(MuMIn) # for checking explanatory power of mixed effects models
library(sjPlot) # for visualising results
library(effects) # for extracting model effects
library(ggplot2) # for plotting
library(merTools) # useful for a few things, but we're using it for extracting estimates for plotting
```

Clear Global Environment

```{r}
rm(list=ls())
```


Read in the data 

```{r}
diversity <- readRDS("UP-TO-DATE.rds") 
```


### Correct for sampling effort across sites within a study

```{r}
studies_check <- diversity %>%
  # filter the rows where Sampling efforts are NA
  filter(is.na(Sampling_effort)) %>%
  # keep only unique studies
  distinct(SS) %>%
  # pull the vector
  pull(SS)

diversity %>%
  # filter the rows where studies are those that had missing sampling efforts (above)
  filter(SS %in% studies_check) %>%
  # drop missing levels
  droplevels() %>%
  # pull out the sampling efforts of these studies
  pull(Sampling_effort)%>%
  # summarise to check that ALL the data are NAs
  summary()

diversity <- diversity %>%
  
  # replace missing sampling effort values with 1
  mutate(x = replace_na(Sampling_effort, 1)) %>%
  
  # group by Study
  group_by(SS) %>%
  
  # check how many sampling efforts there are in each study
  mutate(n_sample_effort = n_distinct(Sampling_effort),
         # get the maximum sampling effort for the studies
         
         max_sample_effort = max(Sampling_effort)
         ) %>%
  
  ungroup() %>%
  
  # if the study has more than one sampling effort, correct the abundance

  # so if there's only one sampling effort, then create a 'dummy sampling effort' of 1 so that we don't change the abundances when we do the divisions. Otherwise, we give it the maximum sampling effort.
  mutate(DividingEffort = ifelse(n_sample_effort == 1, 1, max_sample_effort)) %>%
  
  # if the diversity metric isn't sensitive to the effort, then we'll change the value to 1 too (so we won't end up changing the measurement), otherwise leave it as it is
  mutate(DividingEffort = ifelse(Diversity_metric_is_effort_sensitive == FALSE, 1, DividingEffort)) %>%
  
  # now let's create the effort corrected measurement by dividing the abundances by the sampling efforts
  mutate(Corrected_sampling_effort = Sampling_effort / max_sample_effort,
         Effort_corrected_measurement = Measurement * Corrected_sampling_effort) 

# summarise the corrected sampling efforts
summary(diversity$Corrected_sampling_effort)
```

Test what we have done works
```{r}
diversity %>% 
  # filter out the test study
  filter(SS == "AD1_2001__Liow 1") %>% 
  # select out the columns to check
  dplyr::select(Measurement, Effort_corrected_measurement, Sampling_effort, Corrected_sampling_effort)

darvill_test <- diversity %>% 
  filter(SS == "AD1_2004__Darvill 1") %>% 
  dplyr::select(Measurement, Effort_corrected_measurement)

darvill_test
```

###  Merge any sites that are within the same land-use type and that have identical coordinates, start and end dates

```{r}
diversity <- diversity %>%
  
  # group by aspects of the sites that should be identical if we need to merge the abundances
  # I only want to merge abundances if they are within the same study and block
  # as I'm assuming that even if the locations and sampling times are the same, if the blocks or studies are different, then there is some good reason for this.
  group_by(Source_ID, Study_number, Study_name, Block,
           #diversity metric type
           Diversity_metric, Diversity_metric_type, Diversity_metric_unit,
           Diversity_metric_is_effort_sensitive,
           
           #details of the sites
           Predominant_habitat, Use_intensity, Years_since_fragmentation_or_conversion,
           
           #details of the sampling method
           Sampling_method, Sampling_effort_unit,
           
           #species identity
           Study_common_taxon, Rank_of_study_common_taxon,
           Taxon_number, Taxon_name_entered,
           Indication, Parsed_name,
           Best_guess_binomial, COL_ID, Taxon, Name_status,
           Rank, Kingdom, Phylum, Class, Order, Family, Genus, Species,
           Higher_taxon,
           
           #site location
           Longitude, Latitude,
           
           #sampling time
           Sample_start_earliest, Sample_end_latest, Sample_date_resolution) %>%
  
  # if the diversity metric is occurrence:
  #   if it is present at all, give it a 1, if it is always absent, give it a 0,
  # otherwise (if the metric is either abundance or species richness):
  #   calculate the weighted abundance/richness for each taxonomic group, weighted by sampling effort
  
  mutate(merged_diversity = 
           ifelse(Diversity_metric_type == "Occurrence",
                  # if any of the occurrence values are 1, `any` will return TRUE. If you sum a logical, TRUE becomes 1 and FALSE becomes 0
                  sum(any(Effort_corrected_measurement > 0)),
                  
                  # note that since we've already corrected the sampling effort, this is essentially a mean rather than a weighted mean for abundance measurements. It's a weighted mean for species richness though where sampling efforts vary.
                  stats::weighted.mean(x = Effort_corrected_measurement,
                                       w = Corrected_sampling_effort))
         )

# pull out the grouping data (so we can double check how many records we're merging for each)
group_dat <- diversity %>% 
  group_data() %>%
  mutate(nvals_merged = lengths(.rows),
         merge_ID = row_number())

# ungroup the diversity data for future use
diversity <- ungroup(diversity)

# create a dataset where we can extract just the merged data if we want to
diversity_merged <- diversity %>%
  left_join(group_dat)
```

Check that what we have done has worked - row numbers should be equal right now

```{r}
nrow(diversity) == nrow(diversity_merged)
```

More tests to make sure it has worked

```{r}
test_data <- diversity_merged %>%
  filter(nvals_merged > 1) %>%
  distinct(merge_ID, .keep_all = TRUE)

test1 <- diversity_merged %>%
  filter(merge_ID == test_data$merge_ID[1]) %>%
  dplyr::select(SS, SSB,
         Diversity_metric, Diversity_metric_type, Diversity_metric_unit,
         Predominant_habitat, Use_intensity, Years_since_fragmentation_or_conversion,
         Sampling_method, Sampling_effort_unit,
         Study_common_taxon, Rank_of_study_common_taxon,
         Taxon_name_entered,
         Best_guess_binomial,
         Longitude, Latitude,
         Sample_start_earliest, Sample_end_latest, Sample_date_resolution,
         Effort_corrected_measurement,
         Corrected_sampling_effort,
         merged_diversity,
         .rows,
         nvals_merged,
         merge_ID
         )

test1

paste(test_data$SS[8000])
```

```{r}
test2 <- diversity_merged %>%
  filter(merge_ID == test_data$merge_ID[8000]) %>%
  dplyr::select(SS, SSB,
         Diversity_metric, Diversity_metric_type, Diversity_metric_unit,
         Predominant_habitat, Use_intensity, Years_since_fragmentation_or_conversion,
         Sampling_method, Sampling_effort_unit,
         Study_common_taxon, Rank_of_study_common_taxon,
         Taxon_name_entered,
         Best_guess_binomial,
         Longitude, Latitude,
         Sample_start_earliest, Sample_end_latest, Sample_date_resolution,
         Effort_corrected_measurement,
         Corrected_sampling_effort,
         merged_diversity,
         .rows,
         nvals_merged,
         merge_ID
         )

test2
```

Check studies that didn't need merging

```{r}
test_data <- diversity_merged %>%
  filter(nvals_merged == 1) %>%
  distinct(merge_ID, .keep_all = TRUE)

paste(test_data$SS[1])


test3 <- diversity_merged %>%
  filter(merge_ID == test_data$merge_ID[1]) %>%
  dplyr::select(SS, SSB,
         Diversity_metric, Diversity_metric_type, Diversity_metric_unit,
         Predominant_habitat, Use_intensity, Years_since_fragmentation_or_conversion,
         Sampling_method, Sampling_effort_unit,
         Study_common_taxon, Rank_of_study_common_taxon,
         Taxon_name_entered,
         Best_guess_binomial,
         Longitude, Latitude,
         Sample_start_earliest, Sample_end_latest, Sample_date_resolution,
         Effort_corrected_measurement,
         Corrected_sampling_effort,
         merged_diversity,
         .rows,
         nvals_merged,
         merge_ID
         ) 

test3
```

### Calculate Diversity Metrics 

```{r}
sites <- diversity_merged %>%
  
  # pull out only the merged diversity data
  distinct(merge_ID, .keep_all = TRUE) %>%
  
  # re-make SSB and SSBS values since we've now dropped a bunch of values
  mutate(SS = paste(Source_ID, Study_number),
         SSB = paste(SS, Block),
         SSBS = paste(SSB, Site_number)) %>%
  
  # group by SSBS (each unique value corresponds to a unique site)
  group_by(SSBS) %>%
  
  # now add up all the abundance measurements within each site
  mutate(TotalAbundance = ifelse(Diversity_metric_type == "Abundance",
                                 sum(merged_diversity),
                                 # if the diversity metric type isn't Abundance, then leave the TotalAbundance measurement as NA
                                 NA),
         
         SpeciesRichness = ifelse(Diversity_metric_type == "Species richness",
                                  merged_diversity,
                                  # for abundance and occurrence measurements, count the number of unique species names that are present at the site 
                                  n_distinct(Best_guess_binomial[merged_diversity > 0]))) %>%
  
  # ungroup
  ungroup() %>%
  
  # pull out unique sites
  distinct(SSBS, .keep_all = TRUE) %>%
  
  # now group by Study ID
  group_by(SS) %>%
  
  # pull out the maximum abundance for each study
  mutate(MaxAbundance = max(TotalAbundance)) %>%
  
  # ungroup
  ungroup() %>%
  
  # now rescale total abundance, so that within each study, abundance varies from 0 to 1.
  mutate(RescaledAbundance = TotalAbundance/MaxAbundance) %>%
  
  mutate(sqrtRescaledAbundance = sqrt(RescaledAbundance))
```

### Adding in livestock data 

reading in map

```{r}
livestock_da <- raster("5_Ct_2010_Da.tif")
```

Pull out livestock values for my sites 

```{r}
# get the coordinates from the sites dataset
point_coords <- dplyr::select(sites, Longitude, Latitude)

# extract the HPD values for these coordinates
livestock_da_value <- raster::extract(livestock_da, point_coords)

# take a look at the data
head(livestock_da_value)

# place these data into the sites dataframe, adding a column called hpd and a log-transformed hpd column
sites <- mutate(sites, 
                Livestock = livestock_da_value,
                loglivestock = log(Livestock + 1))
```

read in pixel area data

```{r}
pixel_area <- raster("8_Areakm.tif")
```

Create new column of livestock density

```{r}
#extract pixel area values for the coordinates
pixel_area_value <- raster::extract(pixel_area, point_coords)

#create new column in sites dataframe of cattle density (stock per km2)
sites <- mutate(sites,
                LivestockDensity = livestock_da_value/pixel_area_value,
                logLivestockDensity = log(LivestockDensity + 1))
```


### Subsetting the data 

Rename predominant habitat to land use 

```{r}
sites <- rename(sites,
                Predominant_land_use = Predominant_habitat)
```

Subsetting for the following data:
- Just insect data
- Dung Beetles and Orthoptera in pasture 

```{r}
#Subset data frame for insects
insects <- droplevels(subset(sites, Class == "Insecta")) 

#Subset for orthoptera and Dungbeetles 
mydata<-droplevels(subset(insects, ( Family == "Scarabaeidae" | Family == "Geotrupidae" | Order == "Orthoptera" ) & Predominant_land_use == "Pasture"))

```

Need to remove the land use 'Cannot Decide' as I am interested in different intensities 

```{r}
mydata<-droplevels(subset(mydata, (Use_intensity != "Cannot decide")))
```

Looking at how many sites there are for each land use intensity for dung beetles and for orthoptera 

```{r}
table(mydata$Order, mydata$Use_intensity)
```



## Modelling Site Level Diversity

### Checking Collinearity Between Explanatory Variables

```{r}
#install function used for checking collinearity
source("https://highstat.com/Books/Book2/HighstatLibV10.R")

#check for collinearity between explanatory variables
corvif(mydata[ , c("Use_intensity", "LivestockDensity", "Order")])
```
Collinearity all looks good

### Making sure we have complete cases

```{r}
#only complete cases for abundance across the explanatory values 
model_data_ab <- drop_na(mydata, 
                         RescaledAbundance, logLivestockDensity,
                         Use_intensity, Order)

#only complete cases for species richness across the explanatory values 
model_data_sr <- drop_na(mydata, 
                         SpeciesRichness, logLivestockDensity,
                         Use_intensity, Order)
```

### Visualising the data 

```{r}
#plot a boxplot to see if there seems to be any relationship between use intensity and livestock density
ggplot(model_data_ab, aes(x = Use_intensity, y = logLivestockDensity, colour = Order)) +
  geom_boxplot() 

#Plots of how land use intensity impacts abundance and species richness of the different orders 
ggplot(model_data_ab, aes(x = Use_intensity, y = sqrtRescaledAbundance)) +
  geom_boxplot() + facet_wrap(~Order)

ggplot(model_data_sr, aes(x = Use_intensity, y = SpeciesRichness)) +
  geom_boxplot() + facet_wrap(~Order)

#Plots of how livestock density impacts abundance and species richness of the different orders 
ggplot(model_data_ab, aes(x = logLivestockDensity, y = sqrtRescaledAbundance)) +
  geom_point() + facet_wrap(~Order)

ggplot(model_data_sr, aes(x = logLivestockDensity, y = SpeciesRichness)) +
  geom_point() + facet_wrap(~Order)
```

### Building model

```{r}
#model looking at abundance
m1<- lmer(sqrtRescaledAbundance ~ Use_intensity * Order + logLivestockDensity * Order + (1 | SS) + (1 | SSB), data = model_data_ab)

summary(m1)

#model looking at species richness
m2 <- glmer(SpeciesRichness ~ Use_intensity * Order + logLivestockDensity * Order + (1 | SS) + (1 | SSB), data = model_data_sr, family = "poisson")

summary(m2)
```

### now doing model with all orders of insects 

Need to remove the land use 'Cannot Decide' as I am interested in different intensities 

```{r}
all_insects<-droplevels(subset(insects, (Use_intensity != "Cannot decide")))

all_insects<- droplevels(subset(insects, (Order != "")))
```

Looking at how many sites there are for each land use intensity for each order

```{r}
table(all_insects$Order, all_insects$Use_intensity)
```

Collapse insect orders where there isn't much data into a 'other insects' group

```{r}
all_insects <- all_insects %>%
  
  mutate(
    
    # collapse Blattodea, Dermaptera, Diptera, Isoptera, Odonata and Thysanoptera as these aren't well distinguished
    Order = recode_factor(Order, "Blattodea" = "Other Insects", "Dermaptera" = "Other Insects",
                          "Diptera" = "Other Insects", "Isoptera" = "Other Insects",
                          "Odonata" = "Other Insects", "Thysanoptera" = "Other Insects"))
```

Looking again at how many sites there are now

```{r}
table(all_insects$Order, all_insects$Use_intensity)
```

Making sure we have complete cases

```{r}
#only complete cases for abundance across the explanatory values 
model_data_ab_b <- drop_na(all_insects, 
                         sqrtRescaledAbundance, logLivestockDensity,
                         Use_intensity, Order)

#only complete cases for species richness across the explanatory values 
model_data_sr_b <- drop_na(all_insects, 
                         SpeciesRichness, logLivestockDensity,
                         Use_intensity, Order)
```

Visualise the data 

```{r}
#plot a boxplot to see if there seems to be any relationship between use intensity and livestock density
ggplot(model_data_ab_b, aes(x = Use_intensity, y = logLivestockDensity)) +
  geom_boxplot() + facet_wrap(~Region)

#Plots of how land use intensity impacts abundance and species richness of the different orders 
ggplot(model_data_ab_b, aes(x = Use_intensity, y = sqrtRescaledAbundance)) +
  geom_boxplot()+ facet_wrap(~Region)

ggplot(model_data_sr_b, aes(x = Use_intensity, y = SpeciesRichness)) +
  geom_boxplot() + facet_wrap(~Order)

#Plots of how livestock density impacts abundance and species richness of the different orders 
ggplot(model_data_ab_b, aes(x = logLivestockDensity, y = sqrtRescaledAbundance)) +
  geom_point() + facet_wrap(~Order)

ggplot(model_data_sr_b, aes(x = logLivestockDensity, y = SpeciesRichness)) +
  geom_point() + facet_wrap(~Order)
```

Build model

```{r}
#model looking at abundance
m1b<- lmer(sqrtRescaledAbundance ~ Use_intensity * Order + logLivestockDensity * Order + (1 | SS) + (1 | SSB), (1 | Region), data = model_data_ab_b)

summary(m1)
 #second model here crashes my computer
```


### model of how land use change in savannas impacts the two 

Subset the data for dung beetles and orthoptera in savannas 
```{r}
#Subset data frame for insects
insects <- droplevels(subset(sites, Class == "Insecta")) 

#Subset for orthoptera and Dungbeetles in savannas

mydata_db <- droplevels(subset(insects, Family == "Scarabaeidae" | Family == "Geotrupidae" | Order == "Orthoptera"))

mydata_db <- droplevels(subset(mydata_db, Biome == "Tropical & Subtropical Grasslands, Savannas & Shrublands" | Biome == "Flooded Grasslands & Savannas" | Biome == "Temperate Grasslands, Savannas & Shrublands" | Biome == "Montane Grasslands & Shrublands"))

```

Need to remove the land use 'Cannot Decide' as I am interested in different intensities 

```{r}
mydata_b<-droplevels(subset(mydata_b, (Use_intensity != "Cannot decide")))
```

Looking at how many sites there are for each land use intensity for dung beetles and for orthoptera 

```{r}
table(mydata_db$Order, mydata_db$Predominant_land_use)
```
